{"ast":null,"code":"import { __rest, __assign } from 'tslib';\nimport sync from 'framesync';\nimport { number, color, px, degrees, scale, alpha, progressPercentage } from 'style-value-types';\nimport { invariant } from 'hey-listen';\n\nvar createStyler = function (_a) {\n  var onRead = _a.onRead,\n      onRender = _a.onRender,\n      _b = _a.uncachedValues,\n      uncachedValues = _b === void 0 ? new Set() : _b,\n      _c = _a.useCache,\n      useCache = _c === void 0 ? true : _c;\n  return function (_a) {\n    if (_a === void 0) {\n      _a = {};\n    }\n\n    var props = __rest(_a, []);\n\n    var state = {};\n    var changedValues = [];\n    var hasChanged = false;\n\n    function setValue(key, value) {\n      if (key.startsWith('--')) {\n        props.hasCSSVariable = true;\n      }\n\n      var currentValue = state[key];\n      state[key] = value;\n      if (state[key] === currentValue) return;\n\n      if (changedValues.indexOf(key) === -1) {\n        changedValues.push(key);\n      }\n\n      if (!hasChanged) {\n        hasChanged = true;\n        sync.render(styler.render);\n      }\n    }\n\n    var styler = {\n      get: function (key, forceRead) {\n        if (forceRead === void 0) {\n          forceRead = false;\n        }\n\n        var useCached = !forceRead && useCache && !uncachedValues.has(key) && state[key] !== undefined;\n        return useCached ? state[key] : onRead(key, props);\n      },\n      set: function (values, value) {\n        if (typeof values === 'string') {\n          setValue(values, value);\n        } else {\n          for (var key in values) {\n            setValue(key, values[key]);\n          }\n        }\n\n        return this;\n      },\n      render: function (forceRender) {\n        if (forceRender === void 0) {\n          forceRender = false;\n        }\n\n        if (hasChanged || forceRender === true) {\n          onRender(state, props, changedValues);\n          hasChanged = false;\n          changedValues.length = 0;\n        }\n\n        return this;\n      }\n    };\n    return styler;\n  };\n};\n\nvar CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;\nvar REPLACE_TEMPLATE = '$1-$2';\n\nvar camelToDash = function (str) {\n  return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();\n};\n\nvar camelCache = /*#__PURE__*/new Map();\nvar dashCache = /*#__PURE__*/new Map();\nvar prefixes = ['Webkit', 'Moz', 'O', 'ms', ''];\nvar numPrefixes = prefixes.length;\nvar isBrowser = typeof document !== 'undefined';\nvar testElement;\n\nvar setDashPrefix = function (key, prefixed) {\n  return dashCache.set(key, camelToDash(prefixed));\n};\n\nvar testPrefix = function (key) {\n  testElement = testElement || document.createElement('div');\n\n  for (var i = 0; i < numPrefixes; i++) {\n    var prefix = prefixes[i];\n    var noPrefix = prefix === '';\n    var prefixedPropertyName = noPrefix ? key : prefix + key.charAt(0).toUpperCase() + key.slice(1);\n\n    if (prefixedPropertyName in testElement.style || noPrefix) {\n      if (noPrefix && key === 'clipPath' && dashCache.has(key)) {\n        return;\n      }\n\n      camelCache.set(key, prefixedPropertyName);\n      setDashPrefix(key, \"\" + (noPrefix ? '' : '-') + camelToDash(prefixedPropertyName));\n    }\n  }\n};\n\nvar setServerProperty = function (key) {\n  return setDashPrefix(key, key);\n};\n\nvar prefixer = function (key, asDashCase) {\n  if (asDashCase === void 0) {\n    asDashCase = false;\n  }\n\n  var cache = asDashCase ? dashCache : camelCache;\n\n  if (!cache.has(key)) {\n    isBrowser ? testPrefix(key) : setServerProperty(key);\n  }\n\n  return cache.get(key) || key;\n};\n\nvar axes = ['', 'X', 'Y', 'Z'];\nvar order = ['translate', 'scale', 'rotate', 'skew', 'transformPerspective'];\nvar transformProps = /*#__PURE__*/order.reduce(function (acc, key) {\n  return axes.reduce(function (axesAcc, axesKey) {\n    axesAcc.push(key + axesKey);\n    return axesAcc;\n  }, acc);\n}, ['x', 'y', 'z']);\nvar transformPropDictionary = /*#__PURE__*/transformProps.reduce(function (dict, key) {\n  dict[key] = true;\n  return dict;\n}, {});\n\nfunction isTransformProp(key) {\n  return transformPropDictionary[key] === true;\n}\n\nfunction sortTransformProps(a, b) {\n  return transformProps.indexOf(a) - transformProps.indexOf(b);\n}\n\nvar transformOriginProps = /*#__PURE__*/new Set(['originX', 'originY', 'originZ']);\n\nfunction isTransformOriginProp(key) {\n  return transformOriginProps.has(key);\n}\n\nvar int = /*#__PURE__*/__assign( /*#__PURE__*/__assign({}, number), {\n  transform: Math.round\n});\n\nvar valueTypes = {\n  color: color,\n  backgroundColor: color,\n  outlineColor: color,\n  fill: color,\n  stroke: color,\n  borderColor: color,\n  borderTopColor: color,\n  borderRightColor: color,\n  borderBottomColor: color,\n  borderLeftColor: color,\n  borderWidth: px,\n  borderTopWidth: px,\n  borderRightWidth: px,\n  borderBottomWidth: px,\n  borderLeftWidth: px,\n  borderRadius: px,\n  radius: px,\n  borderTopLeftRadius: px,\n  borderTopRightRadius: px,\n  borderBottomRightRadius: px,\n  borderBottomLeftRadius: px,\n  width: px,\n  maxWidth: px,\n  height: px,\n  maxHeight: px,\n  size: px,\n  top: px,\n  right: px,\n  bottom: px,\n  left: px,\n  padding: px,\n  paddingTop: px,\n  paddingRight: px,\n  paddingBottom: px,\n  paddingLeft: px,\n  margin: px,\n  marginTop: px,\n  marginRight: px,\n  marginBottom: px,\n  marginLeft: px,\n  rotate: degrees,\n  rotateX: degrees,\n  rotateY: degrees,\n  rotateZ: degrees,\n  scale: scale,\n  scaleX: scale,\n  scaleY: scale,\n  scaleZ: scale,\n  skew: degrees,\n  skewX: degrees,\n  skewY: degrees,\n  distance: px,\n  translateX: px,\n  translateY: px,\n  translateZ: px,\n  x: px,\n  y: px,\n  z: px,\n  perspective: px,\n  opacity: alpha,\n  originX: progressPercentage,\n  originY: progressPercentage,\n  originZ: px,\n  zIndex: int,\n  fillOpacity: alpha,\n  strokeOpacity: alpha,\n  numOctaves: int\n};\n\nvar getValueType = function (key) {\n  return valueTypes[key];\n};\n\nvar getValueAsType = function (value, type) {\n  return type && typeof value === 'number' ? type.transform(value) : value;\n};\n\nvar SCROLL_LEFT = 'scrollLeft';\nvar SCROLL_TOP = 'scrollTop';\nvar scrollKeys = /*#__PURE__*/new Set([SCROLL_LEFT, SCROLL_TOP]);\nvar blacklist = /*#__PURE__*/new Set([SCROLL_LEFT, SCROLL_TOP, 'transform']);\nvar translateAlias = {\n  x: 'translateX',\n  y: 'translateY',\n  z: 'translateZ'\n};\n\nfunction isCustomTemplate(v) {\n  return typeof v === 'function';\n}\n\nfunction buildTransform(state, transform, transformKeys, transformIsDefault, enableHardwareAcceleration, allowTransformNone) {\n  if (allowTransformNone === void 0) {\n    allowTransformNone = true;\n  }\n\n  var transformString = '';\n  var transformHasZ = false;\n  transformKeys.sort(sortTransformProps);\n  var numTransformKeys = transformKeys.length;\n\n  for (var i = 0; i < numTransformKeys; i++) {\n    var key = transformKeys[i];\n    transformString += (translateAlias[key] || key) + \"(\" + transform[key] + \") \";\n    transformHasZ = key === 'z' ? true : transformHasZ;\n  }\n\n  if (!transformHasZ && enableHardwareAcceleration) {\n    transformString += 'translateZ(0)';\n  } else {\n    transformString = transformString.trim();\n  }\n\n  if (isCustomTemplate(state.transform)) {\n    transformString = state.transform(transform, transformIsDefault ? '' : transformString);\n  } else if (allowTransformNone && transformIsDefault) {\n    transformString = 'none';\n  }\n\n  return transformString;\n}\n\nfunction buildStyleProperty(state, enableHardwareAcceleration, styles, transform, transformOrigin, transformKeys, isDashCase, allowTransformNone) {\n  if (enableHardwareAcceleration === void 0) {\n    enableHardwareAcceleration = true;\n  }\n\n  if (styles === void 0) {\n    styles = {};\n  }\n\n  if (transform === void 0) {\n    transform = {};\n  }\n\n  if (transformOrigin === void 0) {\n    transformOrigin = {};\n  }\n\n  if (transformKeys === void 0) {\n    transformKeys = [];\n  }\n\n  if (isDashCase === void 0) {\n    isDashCase = false;\n  }\n\n  if (allowTransformNone === void 0) {\n    allowTransformNone = true;\n  }\n\n  var transformIsDefault = true;\n  var hasTransform = false;\n  var hasTransformOrigin = false;\n\n  for (var key in state) {\n    var value = state[key];\n    var valueType = getValueType(key);\n    var valueAsType = getValueAsType(value, valueType);\n\n    if (isTransformProp(key)) {\n      hasTransform = true;\n      transform[key] = valueAsType;\n      transformKeys.push(key);\n\n      if (transformIsDefault) {\n        if (valueType.default && value !== valueType.default || !valueType.default && value !== 0) {\n          transformIsDefault = false;\n        }\n      }\n    } else if (isTransformOriginProp(key)) {\n      transformOrigin[key] = valueAsType;\n      hasTransformOrigin = true;\n    } else if (!blacklist.has(key) || !isCustomTemplate(valueAsType)) {\n      styles[prefixer(key, isDashCase)] = valueAsType;\n    }\n  }\n\n  if (hasTransform || typeof state.transform === 'function') {\n    styles.transform = buildTransform(state, transform, transformKeys, transformIsDefault, enableHardwareAcceleration, allowTransformNone);\n  }\n\n  if (hasTransformOrigin) {\n    styles.transformOrigin = (transformOrigin.originX || '50%') + \" \" + (transformOrigin.originY || '50%') + \" \" + (transformOrigin.originZ || 0);\n  }\n\n  return styles;\n}\n\nfunction createStyleBuilder(_a) {\n  var _b = _a === void 0 ? {} : _a,\n      _c = _b.enableHardwareAcceleration,\n      enableHardwareAcceleration = _c === void 0 ? true : _c,\n      _d = _b.isDashCase,\n      isDashCase = _d === void 0 ? true : _d,\n      _e = _b.allowTransformNone,\n      allowTransformNone = _e === void 0 ? true : _e;\n\n  var styles = {};\n  var transform = {};\n  var transformOrigin = {};\n  var transformKeys = [];\n  return function (state) {\n    transformKeys.length = 0;\n    buildStyleProperty(state, enableHardwareAcceleration, styles, transform, transformOrigin, transformKeys, isDashCase, allowTransformNone);\n    return styles;\n  };\n}\n\nfunction onRead(key, options) {\n  var element = options.element,\n      preparseOutput = options.preparseOutput;\n  var defaultValueType = getValueType(key);\n\n  if (isTransformProp(key)) {\n    return defaultValueType ? defaultValueType.default || 0 : 0;\n  } else if (scrollKeys.has(key)) {\n    return element[key];\n  } else {\n    var domValue = window.getComputedStyle(element, null).getPropertyValue(prefixer(key, true)) || 0;\n    return preparseOutput && defaultValueType && defaultValueType.test(domValue) && defaultValueType.parse ? defaultValueType.parse(domValue) : domValue;\n  }\n}\n\nfunction onRender(state, _a, changedValues) {\n  var element = _a.element,\n      buildStyles = _a.buildStyles,\n      hasCSSVariable = _a.hasCSSVariable;\n  Object.assign(element.style, buildStyles(state));\n\n  if (hasCSSVariable) {\n    var numChangedValues = changedValues.length;\n\n    for (var i = 0; i < numChangedValues; i++) {\n      var key = changedValues[i];\n\n      if (key.startsWith('--')) {\n        element.style.setProperty(key, state[key]);\n      }\n    }\n  }\n\n  if (changedValues.indexOf(SCROLL_LEFT) !== -1) {\n    element[SCROLL_LEFT] = state[SCROLL_LEFT];\n  }\n\n  if (changedValues.indexOf(SCROLL_TOP) !== -1) {\n    element[SCROLL_TOP] = state[SCROLL_TOP];\n  }\n}\n\nvar cssStyler = /*#__PURE__*/createStyler({\n  onRead: onRead,\n  onRender: onRender,\n  uncachedValues: scrollKeys\n});\n\nfunction createCssStyler(element, _a) {\n  if (_a === void 0) {\n    _a = {};\n  }\n\n  var enableHardwareAcceleration = _a.enableHardwareAcceleration,\n      allowTransformNone = _a.allowTransformNone,\n      props = __rest(_a, [\"enableHardwareAcceleration\", \"allowTransformNone\"]);\n\n  return cssStyler(__assign({\n    element: element,\n    buildStyles: createStyleBuilder({\n      enableHardwareAcceleration: enableHardwareAcceleration,\n      allowTransformNone: allowTransformNone\n    }),\n    preparseOutput: true\n  }, props));\n}\n\nvar camelCaseAttributes = /*#__PURE__*/new Set(['baseFrequency', 'diffuseConstant', 'kernelMatrix', 'kernelUnitLength', 'keySplines', 'keyTimes', 'limitingConeAngle', 'markerHeight', 'markerWidth', 'numOctaves', 'targetX', 'targetY', 'surfaceScale', 'specularConstant', 'specularExponent', 'stdDeviation', 'tableValues']);\nvar defaultOrigin = 0.5;\n\nvar svgAttrsTemplate = function () {\n  return {\n    style: {}\n  };\n};\n\nvar progressToPixels = function (progress, length) {\n  return px.transform(progress * length);\n};\n\nvar unmeasured = {\n  x: 0,\n  y: 0,\n  width: 0,\n  height: 0\n};\n\nfunction calcOrigin(origin, offset, size) {\n  return typeof origin === 'string' ? origin : px.transform(offset + size * origin);\n}\n\nfunction calculateSVGTransformOrigin(dimensions, originX, originY) {\n  return calcOrigin(originX, dimensions.x, dimensions.width) + \" \" + calcOrigin(originY, dimensions.y, dimensions.height);\n}\n\nvar svgStyleConfig = {\n  enableHardwareAcceleration: false,\n  isDashCase: false\n};\n\nfunction buildSVGAttrs(_a, dimensions, totalPathLength, cssBuilder, attrs, isDashCase) {\n  if (dimensions === void 0) {\n    dimensions = unmeasured;\n  }\n\n  if (cssBuilder === void 0) {\n    cssBuilder = createStyleBuilder(svgStyleConfig);\n  }\n\n  if (attrs === void 0) {\n    attrs = svgAttrsTemplate();\n  }\n\n  if (isDashCase === void 0) {\n    isDashCase = true;\n  }\n\n  var attrX = _a.attrX,\n      attrY = _a.attrY,\n      originX = _a.originX,\n      originY = _a.originY,\n      pathLength = _a.pathLength,\n      _b = _a.pathSpacing,\n      pathSpacing = _b === void 0 ? 1 : _b,\n      _c = _a.pathOffset,\n      pathOffset = _c === void 0 ? 0 : _c,\n      state = __rest(_a, [\"attrX\", \"attrY\", \"originX\", \"originY\", \"pathLength\", \"pathSpacing\", \"pathOffset\"]);\n\n  var style = cssBuilder(state);\n\n  for (var key in style) {\n    if (key === 'transform') {\n      attrs.style.transform = style[key];\n    } else {\n      var attrKey = isDashCase && !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n      attrs[attrKey] = style[key];\n    }\n  }\n\n  if (originX !== undefined || originY !== undefined || style.transform) {\n    attrs.style.transformOrigin = calculateSVGTransformOrigin(dimensions, originX !== undefined ? originX : defaultOrigin, originY !== undefined ? originY : defaultOrigin);\n  }\n\n  if (attrX !== undefined) attrs.x = attrX;\n  if (attrY !== undefined) attrs.y = attrY;\n\n  if (totalPathLength !== undefined && pathLength !== undefined) {\n    attrs[isDashCase ? 'stroke-dashoffset' : 'strokeDashoffset'] = progressToPixels(-pathOffset, totalPathLength);\n    attrs[isDashCase ? 'stroke-dasharray' : 'strokeDasharray'] = progressToPixels(pathLength, totalPathLength) + \" \" + progressToPixels(pathSpacing, totalPathLength);\n  }\n\n  return attrs;\n}\n\nfunction createAttrBuilder(dimensions, totalPathLength, isDashCase) {\n  if (isDashCase === void 0) {\n    isDashCase = true;\n  }\n\n  var attrs = svgAttrsTemplate();\n  var cssBuilder = createStyleBuilder(svgStyleConfig);\n  return function (state) {\n    return buildSVGAttrs(state, dimensions, totalPathLength, cssBuilder, attrs, isDashCase);\n  };\n}\n\nvar getDimensions = function (element) {\n  return typeof element.getBBox === 'function' ? element.getBBox() : element.getBoundingClientRect();\n};\n\nvar getSVGElementDimensions = function (element) {\n  try {\n    return getDimensions(element);\n  } catch (e) {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n  }\n};\n\nvar isPath = function (element) {\n  return element.tagName === 'path';\n};\n\nvar svgStyler = /*#__PURE__*/createStyler({\n  onRead: function (key, _a) {\n    var element = _a.element;\n    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n\n    if (!isTransformProp(key)) {\n      return element.getAttribute(key);\n    } else {\n      var valueType = getValueType(key);\n      return valueType ? valueType.default || 0 : 0;\n    }\n  },\n  onRender: function (state, _a) {\n    var element = _a.element,\n        buildAttrs = _a.buildAttrs;\n    var attrs = buildAttrs(state);\n\n    for (var key in attrs) {\n      if (key === 'style') {\n        Object.assign(element.style, attrs.style);\n      } else {\n        element.setAttribute(key, attrs[key]);\n      }\n    }\n  }\n});\n\nvar svg = function (element) {\n  var dimensions = getSVGElementDimensions(element);\n  var pathLength = isPath(element) && element.getTotalLength ? element.getTotalLength() : undefined;\n  return svgStyler({\n    element: element,\n    buildAttrs: createAttrBuilder(dimensions, pathLength)\n  });\n};\n\nvar viewport = /*#__PURE__*/createStyler({\n  useCache: false,\n  onRead: function (key) {\n    return key === 'scrollTop' ? window.pageYOffset : window.pageXOffset;\n  },\n  onRender: function (_a) {\n    var _b = _a.scrollTop,\n        scrollTop = _b === void 0 ? 0 : _b,\n        _c = _a.scrollLeft,\n        scrollLeft = _c === void 0 ? 0 : _c;\n    return window.scrollTo(scrollLeft, scrollTop);\n  }\n});\nvar cache = /*#__PURE__*/new WeakMap();\n\nvar isHTMLElement = function (node) {\n  return node instanceof HTMLElement || typeof node.click === 'function';\n};\n\nvar isSVGElement = function (node) {\n  return node instanceof SVGElement || 'ownerSVGElement' in node;\n};\n\nvar createDOMStyler = function (node, props) {\n  var styler;\n\n  if (node === window) {\n    styler = viewport(node);\n  } else if (isHTMLElement(node)) {\n    styler = createCssStyler(node, props);\n  } else if (isSVGElement(node)) {\n    styler = svg(node);\n  }\n\n  invariant(styler !== undefined, 'No valid node provided. Node must be HTMLElement, SVGElement or window.');\n  cache.set(node, styler);\n  return styler;\n};\n\nvar getStyler = function (node, props) {\n  return cache.has(node) ? cache.get(node) : createDOMStyler(node, props);\n};\n\nfunction index(nodeOrSelector, props) {\n  var node = typeof nodeOrSelector === 'string' ? document.querySelector(nodeOrSelector) : nodeOrSelector;\n  return getStyler(node, props);\n}\n\nexport default index;\nexport { buildSVGAttrs, buildStyleProperty, createStyler as createStylerFactory, isTransformProp, transformProps };","map":null,"metadata":{},"sourceType":"module"}